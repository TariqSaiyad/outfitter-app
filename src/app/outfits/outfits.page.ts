import { Component, OnInit } from '@angular/core';
import { AngularFireAuth } from '@angular/fire/auth';
import { Router, ActivatedRoute } from '@angular/router';
import { PopoverController } from '@ionic/angular';
import { OutfitComponent } from '../outfit/outfit.component';
import { LoadingController } from '@ionic/angular';

export interface IWindow extends Window {
  webkitSpeechRecognition: any;
}

@Component({
  selector: 'app-outfits',
  templateUrl: './outfits.page.html',
  styleUrls: ['./outfits.page.scss'],
})

/**
 * This is the outfit page, which displays all the items stored in the database.
 * This page is responsible for parsing all the item ids into item objects. 
 */
export class OutfitsPage implements OnInit {
  data: Array<any>; //this is the outfit data from the database.
  allItems: Array<any>; //these are all the items in the database.
  outfits = []; // this is the final list of outfits.
  randomOutfit; // this is the random outfit generated by the app

  webkitSpeechRecognition: IWindow = <IWindow>window; // the webspeech api built in

  constructor(
    public loadingController: LoadingController,
    public popoverController: PopoverController,
    private route: ActivatedRoute,
    private router: Router,
    public afAuth: AngularFireAuth) {
  }

  /**
   * This uses the firebase auth service to log out the user.
   */
  signOut() {
    this.afAuth.auth
    this.afAuth.auth.signOut().then(() => {
      location.reload();
    });
  }

  /**
   * This loads the data into the outfits list.
   */
  ngOnInit() {
    if (this.route && this.route.data) {
      this.getData();
    }
  }

  /**
   * This performs the same functions as above, on page load.
   */
  ionViewWillEnter() {
    if (this.route && this.route.data) {
      this.getData();
    }
    this.startSpeech();
  }

  /**
   * This presents the progress loading circle.
   */
  async presentLoading() {
    const loading = await this.loadingController.create({
      showBackdrop: false,
      spinner: 'crescent',
      duration: 1000,
      translucent: false,
      cssClass: 'custom-class custom-loading',
    });
    return await loading.present();
  }

  /**
   * This gets data from the firebase database service.
   */
  async getData() {
    //encapsulated in a promsise, to avoid async issues.
    // this will resolve the outfit objects from the database.
    // but this list of items will only contain the ids, not the 
    //actual objects. 
    var dataPromise = new Promise<any>((resolve, reject) => {
      this.route.data.subscribe(routeData => {
        routeData['data'].subscribe(data => {
          this.data = data;
          resolve(this.data);
        });
      });

    });

    //this resolves all item objects from the database, used
    // for parsing later.
    var itemsPromise = new Promise<any>((resolve, reject) => {
      this.route.data.subscribe(routeData => {
        routeData['items'].subscribe(data => {
          this.allItems = data;
          resolve(this.allItems);
        });
      });
    });

    // this resolves both of the above promises.
    dataPromise.then((resolve) => {
      itemsPromise.then((value) => {
        //once all data is loaded, then parse outfits.
        this.parseAllOutfits();
        console.log(this.outfits);
      })
    })
  }

  /**
   * This will display the outfit that is clicked on
   * using the outfit component.
   * @param outfit the outfit to be viewed
   * @param ev event that is triggered.
   */
  async showPopover(outfit, ev: any) {
    //create the popover to show outfit
    const popover = await this.popoverController.create({
      component: OutfitComponent,
      //send the outfit data as parameter.
      componentProps: { "outfit": outfit },
      event: ev,
      animated: true,
      translucent: false,
      cssClass: 'pop-over-style'
    });
    return await popover.present();
  }

  /**
   * This function will create a random outfit using the user's 
   * items and display it to the user.
   */
  feelingLucky() {
    //the fields to store the items.
    let layerItems = []
    let accItems = []
    let pantItem;
    let shoeItem;
    // make a copy of the items.
    let shuffleItems = this.allItems;
    // shuffle all items to make it random.
    shuffleItems.sort(() => Math.random() - 0.5);
    //go through all the items.
    for (let i = 0; i < shuffleItems.length; i++) {
      //get the item object.
      let item = shuffleItems[i];
      //get the category of item.
      let itemCat = item.payload.doc.data().category;
      //if the item category matches this, then add it to the list and continue.
      if (itemCat == "Shirts" || itemCat == "Jackets" || itemCat == "Hoodies") {
        if (layerItems.length == 2) { continue; }
        layerItems.push(item);
      }
      if (itemCat == "Accessories") {
        if (accItems.length == 2) { continue; }
        accItems.push(item);
      }
      if (itemCat == "Pants" || itemCat == "Shorts") {
        pantItem = item;
      }
      if (itemCat == "Shoes") {
        shoeItem = item;
      }
    }
    //once all the items are received, make the outfit object.
    this.randomOutfit = {
      outfitName: "My Random Outfit",
      layers: layerItems,
      accessories: accItems,
      pants: pantItem,
      shoes: shoeItem,
      id: "randID"
    }
    //create popover for the outfit.
    this.showPopover(this.randomOutfit, null);
  }

  /**
   * This will go through the outfit data, and parse each outfit 
   * with item objects.
   */
  parseAllOutfits() {
    //create empty outfit list. 
    let outfitList = []
    for (let i = 0; i < this.data.length; i++) {
      //parse each outfit and add to list.
      outfitList.push(this.parseOutfit(this.data[i]));
    }
    //store the list in field.
    this.outfits = outfitList;
  }

  /**
   * This will go through each item of the outfit, and get the corresponding 
   * object for it.
   * @param o the outfit to be parsed.
   */
  parseOutfit(o) {
    // the fields for the items.
    let layerItems = []
    let accItems = []
    let pantItem;
    let shoeItem;

    //get the list for the layer, accessories.
    let layer = o.payload.doc.data().layers;
    let accessory = o.payload.doc.data().accessories;

    //go through all items in the database.
    for (let i = 0; i < this.allItems.length; i++) {
      //get the item object.
      let item = this.allItems[i];
      //go through each item in this outfits layers.
      for (let l = 0; l < layer.length; l++) {
        //get the item object using the id if there is a match
        if (item.payload.doc.id == layer[l]) {
          //save item object.
          layerItems.push(item);
          continue;
        }
      }
      //below is the same process for the rest of 
      // the item categories.

      //accessory parsing.
      for (let a = 0; a < accessory.length; a++) {
        //get the item object using the id.
        if (item.payload.doc.id == accessory[a]) {
          accItems.push(item);
          continue;
        }
      }
      //pants parsing.
      if (item.payload.doc.id == o.payload.doc.data().pants) {
        pantItem = item;
        continue;
      }
      //shoes parsing.
      if (item.payload.doc.id == o.payload.doc.data().shoes) {
        shoeItem = item;
        continue;
      }
    }

    //create the final outfit object, with all parsed items.
    let outfit = {
      //get the name from the outfit.
      outfitName: o.payload.doc.data().outfitName,
      layers: layerItems,
      accessories: accItems,
      pants: pantItem,
      shoes: shoeItem,
      id: o.payload.doc.id
    }
    //return the outfit
    return outfit;
  }

  /**
   * This is the speech recognition that uses webSpeech API.
   * NOTE: currently only supported in chrome
   */
  startSpeech() {
    //get the recognition functions.
    var recognition = new this.webkitSpeechRecognition.webkitSpeechRecognition();
    recognition.onresult = event => {
      const terms = [];
      //extract the transcript
      if (event.results) {
        console.log(event.results);
        for (const result of event.results) {
          for (const ra of result) {
            terms.push(ra.transcript);
          }
        }
        //if 'item' is detected
        if (terms.includes('item') || terms.includes('items') || terms.includes('add item') ||
          terms.includes('add items')) {
          this.router.navigateByUrl('/add-item');
        }
        //if 'outfit' is detected
        else if (terms.includes('outfit') || terms.includes('outfits') || terms.includes('add outfit') ||
          terms.includes('add outfits')) {
          this.router.navigateByUrl('/add-outfit');
        }
      }
    };

    recognition.start();
  }

}
